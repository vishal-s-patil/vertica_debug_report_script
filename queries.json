[
    {
        "qid": 1,
        "query_name": "long_running_queries",
        "query_description": "Long Running Queries",
        "query": "SELECT n.subcluster_name, s.statement_start, s.user_name, CASE WHEN (CURRENT_TIMESTAMP - s.statement_start) > INTERVAL '10 minutes' THEN 'FATAL' WHEN (CURRENT_TIMESTAMP - s.statement_start) > INTERVAL '5 minutes' THEN 'WARN' ELSE 'OK' END AS status FROM sessions as s join nodes as n on n.node_name = s.node_name WHERE 1=1 {status='issue_level'} {user_name='user_name'} and s.statement_id IS NOT NULL and n.subcluster_name = '<subcluster_name>' ORDER BY s.statement_start;",
        "query_past": "select s.snapshot_time, n.subcluster_name, s.statement_start, s.user_name, CASE WHEN (snapshot_time - s.statement_start) > INTERVAL '10 minutes' THEN 'FATAL' WHEN (snapshot_time - s.statement_start) > INTERVAL '5 minutes' THEN 'WARN' ELSE 'OK' END AS status FROM netstats.sessions_full as s join nodes as n on n.node_name = s.node_name where 1=1 and s.statement_id IS NOT NULL and n.subcluster_name = '<subcluster_name>' and snapshot_time >= (timestamp {issue_time} - INTERVAL '{duration} hours') and snapshot_time <= timestamp {issue_time} ORDER BY s.statement_start limit {num_items};"
    },
    {
        "qid": 2,
        "query_name": "sessions",
        "query_description": "Sessions",
        "query": "select * from ( select n.subcluster_name, s.user_name, count(1) as cnt, CASE WHEN COUNT(1) > 100 THEN 'FATAL' WHEN COUNT(1) > 50 THEN 'WARN' ELSE 'OK' END AS status from sessions as s JOIN nodes AS n ON n.node_name = s.node_name WHERE 1 = 1 { user_name = 'user_name' } and n.subcluster_name = '<subcluster_name>' AND (s.statement_id { session_type } NULL { s.statement_id is session_type_2 }) group by n.subcluster_name, s.user_name ORDER BY cnt desc ) as x where 1=1 {x.status='issue_level'};",
        "query_past": "select * from ( WITH ranked_sessions AS ( SELECT n.subcluster_name, user_name, snapshot_time, COUNT(1) AS cnt, CASE WHEN COUNT(1) > {fatal_threshold} THEN 'FATAL' WHEN COUNT(1) > {warn_threshold} THEN 'WARN' ELSE 'OK' END AS status, ROW_NUMBER() OVER ( PARTITION BY snapshot_time ORDER BY cnt DESC ) AS row_num FROM netstats.sessions_full as s join nodes as n on n.node_name = s.node_name WHERE 1 = 1 { user_name = 'user_name' } AND (s.statement_id { session_type } NULL { s.statement_id is session_type_2 } ) { user_name = 'user_name' } and snapshot_time >= ( timestamp { 'issue_time' } - INTERVAL '{duration} hours' ) and snapshot_time <= timestamp { 'issue_time' } and n.subcluster_name = '<subcluster_name>' GROUP BY snapshot_time, user_name, n.subcluster_name ), limited_snapshots AS ( SELECT snapshot_time, ROW_NUMBER() OVER ( ORDER BY snapshot_time ) AS snapshot_rank FROM ranked_sessions GROUP BY snapshot_time ORDER BY snapshot_time ) SELECT rs.snapshot_time, rs.user_name, rs.cnt, subcluster_name, rs.status FROM ranked_sessions rs JOIN limited_snapshots ls ON rs.snapshot_time = ls.snapshot_time WHERE ls.snapshot_rank <= { snapshots } AND rs.row_num <= { user_limit } ORDER BY rs.snapshot_time, rs.cnt DESC ) as x where 1 = 1 { x.status = 'issue_level' };"
    },
    {
        "qid": 3,
        "query_name": "error_messages",
        "query_description": "Error Messages",
        "query": "select * from ( select n.subcluster_name, date_trunc({ granularity }, event_timestamp) as date_trunc, CASE WHEN em.message ILIKE '%memory%' THEN 'memory' WHEN em.message ILIKE '%session%' THEN 'session' WHEN em.message ILIKE '%resource%' THEN 'resource' ELSE 'other' END AS message_category, count(1) as cnt from error_messages as em JOIN nodes AS n ON n.node_name = em.node_name where 1 = 1 and em.event_timestamp >= (TIMESTAMP { 'issue_time' } - INTERVAL '{duration} hour') and n.subcluster_name = '<subcluster_name>' and em.event_timestamp <= { 'issue_time' } group by date_trunc, message_category, n.subcluster_name ORDER BY { order_by } n.subcluster_name limit { num_items } )as x where 1=1 {message_category='err_type'};"
    },
    {
        "qid": 4,
        "query_name": "error_messages_raw",
        "query_description": "Error Messages Raw",
        "query": "select n.subcluster_name, em.event_timestamp, em.user_name, SUBSTRING(em.message, 1, 50) from error_messages as em JOIN nodes AS n ON n.node_name = em.node_name where 1 = 1 { user_name = 'user_name' } and em.event_timestamp >= ( TIMESTAMP { 'from_date_time' } { to_date_time } { 'issue_time' } - INTERVAL '{duration} hour' ) and n.subcluster_name = '<subcluster_name>' and em.event_timestamp <= { 'from_date_time' } { 'to_date_time' } { 'issue_time' } and em.message ilike '%{err_type}%' ORDER BY event_timestamp limit { num_items };"
    },
    {
        "qid": 5,
        "query_name": "queue_status",
        "query_description": "User Wise Queries in Queue",
        "query": "select * from ( SELECT n.subcluster_name, rq.pool_name, COUNT(1) AS cnt, CASE WHEN COUNT(1) > 100 THEN 'FATAL' WHEN COUNT(1) > 50 THEN 'WARN' ELSE 'OK' END AS status FROM resource_queues AS rq JOIN nodes AS n ON n.node_name = rq.node_name WHERE 1 = 1 { pool_name = 'pool_name' } and n.subcluster_name = '<subcluster_name>' GROUP BY n.subcluster_name, rq.pool_name ORDER BY cnt desc ) as x where 1=1 {x.status='issue_level'};",
        "query_past": "select * from ( WITH ranked_sessions AS ( SELECT n.subcluster_name, pool_name, snapshot_time, COUNT(1) AS cnt, CASE WHEN COUNT(1) > {fatal_threshold} THEN 'FATAL' WHEN COUNT(1) > {warn_threshold} THEN 'WARN' ELSE 'OK' END AS status, ROW_NUMBER() OVER ( PARTITION BY snapshot_time ORDER BY cnt DESC ) AS row_num FROM netstats.resource_queues_full as s join nodes as n on n.node_name = s.node_name WHERE 1 = 1 { pool_name = 'pool_name' } and snapshot_time >= ( timestamp { 'issue_time' } - INTERVAL '{duration} hours' ) and snapshot_time <= timestamp { 'issue_time' } and n.subcluster_name = '<subcluster_name>' GROUP BY snapshot_time, pool_name, n.subcluster_name ), limited_snapshots AS ( SELECT snapshot_time, ROW_NUMBER() OVER ( ORDER BY snapshot_time ) AS snapshot_rank FROM ranked_sessions GROUP BY snapshot_time ORDER BY snapshot_time ) SELECT rs.snapshot_time, rs.pool_name, rs.subcluster_name, rs.cnt, rs.status FROM ranked_sessions rs JOIN limited_snapshots ls ON rs.snapshot_time = ls.snapshot_time WHERE ls.snapshot_rank <= { snapshots } AND rs.row_num <= { user_limit } ORDER BY rs.snapshot_time, rs.cnt DESC ) as x where 1 = 1 { x.status = 'issue_level' };"
    },
    {
        "qid": 6,
        "query_name": "sessions_exceeding_limit",
        "query_description": "Sessions Exceeding Max Limit of 1000",
        "query": "SELECT n.subcluster_name, date_trunc({granularity},event_timestamp) as date_trunc, count(1) from error_messages as em JOIN nodes AS n ON n.node_name = em.node_name WHERE 1=1 {user_name='user_name'} and event_timestamp >= (timestamp {'issue_time'} - INTERVAL '{duration} hour') and event_timestamp <= timestamp {'issue_time'} and n.subcluster_name = '<subcluster_name>' and message like '%1000 sessions%' group by n.subcluster_name, date_trunc order by date_trunc desc;"
    },
    {
        "qid": 7,
        "query_name": "query_count",
        "query_description": "Query Count",
        "query": "WITH ranked_queries AS ( SELECT n.subcluster_name, DATE_TRUNC({granularity}, qp.query_start::timestamp) AS date_trunc, qp.user_name, COUNT(1) AS cnt, AVG(qp.query_duration_us) AS avg_query_duration_us, MIN(qp.query_duration_us) AS min_query_duration_us, MAX(qp.query_duration_us) AS max_query_duration_us, AVG(qp.processed_row_count) AS avg_processed_row_count, ROW_NUMBER() OVER ( PARTITION BY DATE_TRUNC({granularity}, qp.query_start::timestamp) ORDER BY COUNT(1) DESC ) AS rank_in_hour FROM netstats.query_profiles AS qp JOIN nodes AS n ON n.node_name = qp.node_name WHERE 1=1 {user_name='user_name'} and query_start>=(timestamp {'issue_time'} - interval '{duration} hour') and query_start<= {'issue_time'} and n.subcluster_name = '<subcluster_name>' and qp.query_start >= DATE_TRUNC({granularity}, query_start) - INTERVAL '{duration} hour' GROUP BY n.subcluster_name, date_trunc, qp.user_name ) SELECT subcluster_name, date_trunc, user_name, cnt, avg_query_duration_us, min_query_duration_us, max_query_duration_us, avg_processed_row_count FROM ranked_queries WHERE rank_in_hour <= 5 ORDER BY date_trunc DESC, cnt DESC;"
    },
    {
        "qid": 8,
        "query_name": "resource_pool_status",
        "query_description": "Status of the Resource Pool",
        "query": "select n.subcluster_name, memory_size_kb, memory_inuse_kb, general_memory_borrowed_kb, max_memory_size_kb, running_query_count from resource_pool_status as rps join nodes as n on n.node_name = rps.node_name where 1 = 1 { pool_name = 'pool_name' } and n.subcluster_name = '<subcluster_name>' order by running_query_count;",
        "query_past": "select null;"
    },
    {
        "qid": 9,
        "query_name": "delete_vectors_count",
        "query_description": "Delete Vectors, Deleted Row Count",
        "query": "select created_time, schema_name, projection_name, sum(total_row_cnt) row_count, sum(deleted_row_cnt) deleted_rows, sum(delete_vector_cnt) dv_count, n.subcluster_name from netstats.storage_containers as sc JOIN nodes AS n ON n.node_name = sc.node_name where 1=1 {projection_name ILIKE 'table_name'} and created_time=(select max(created_time) from netstats.storage_containers) group by created_time, schema_name,projection_name,n.subcluster_name order by {order_by} dv_count desc limit {num_items};"
    },
    {
        "qid": 10,
        "query_name": "catalog_size",
        "query_description": "Catalog Size",
        "query": "select n.subcluster_name, memory_size_kb,general_memory_borrowed_kb,max_memory_size_kb, running_query_count from resource_pool_Status as s join nodes as n on n.node_name=s.node_name where 1=1 and pool_name='metadata' and n.subcluster_name = '<subcluster_name>' order by memory_size_kb desc, general_memory_borrowed_kb desc;"
    }
]