qid~query_name~query~query_description
1~long_running_queries~SELECT n.subcluster_name, s.statement_start, s.user_name, CASE WHEN (CURRENT_TIMESTAMP - s.statement_start) > INTERVAL '10 minutes' THEN 'FATAL' WHEN (CURRENT_TIMESTAMP - s.statement_start) > INTERVAL '5 minutes' THEN 'WARNING' ELSE 'NORMAL' END AS query_status FROM sessions as s join nodes as n on n.node_name = s.node_name WHERE 1=1 and s.statement_id IS NOT NULL and n.subcluster_name = '<subcluster_name>' ORDER BY s.statement_start;~current long running queries.
2~queue_status~SELECT n.subcluster_name, rq.pool_name, COUNT(1) AS cnt, CASE WHEN COUNT(1) > 100 THEN 'FATAL' WHEN COUNT(1) > 50 THEN 'WARNING' ELSE 'NORMAL' END AS status FROM resource_queues AS rq JOIN nodes AS n ON n.node_name = rq.node_name WHERE 1=1 {queue_entry_timestamp>=from_date_time} {queue_entry_timestamp<to_date_time} and n.subcluster_name = '<subcluster_name>' GROUP BY n.subcluster_name, rq.pool_name ORDER BY cnt desc;~user wise query request count in queue. 
3~active_sessions~select n.subcluster_name, s.user_name, count(1) as cnt, CASE WHEN COUNT(1) > 100 THEN 'FATAL' WHEN COUNT(1) > 50 THEN 'WARNING' ELSE 'NORMAL' END AS status from sessions as s JOIN nodes AS n ON n.node_name = s.node_name WHERE 1=1 {statement_start>=from_date_time} {statement_start<to_date_time} and n.subcluster_name = '<subcluster_name>' AND s.statement_id is NOT NULL group by n.subcluster_name, s.user_name ORDER BY cnt desc;~user wise number of active sessions.
4~inactive_sessions~select n.subcluster_name, s.user_name, count(1) as cnt, CASE WHEN COUNT(1) > 100 THEN 'FATAL' WHEN COUNT(1) > 50 THEN 'WARNING' ELSE 'NORMAL' END AS status from sessions as s JOIN nodes AS n ON n.node_name = s.node_name WHERE 1=1 {statement_start>=from_date_time} {statement_start<to_date_time} and n.subcluster_name = '<subcluster_name>' AND s.statement_id is NULL group by n.subcluster_name, s.user_name ORDER BY cnt desc;~user wise number of inactive sessions.
5~sessions_exceeding_limit~SELECT n.subcluster_name, date_trunc('hour',event_timestamp) as date_trunc_hour, count(1) from netstats.error_messages as em JOIN nodes AS n ON n.node_name = em.node_name WHERE 1=1 {event_timestamp>=from_date_time} {event_timestamp<to_date_time} and n.subcluster_name = '<subcluster_name>' and message like '%1000 sessions%' group by n.subcluster_name, date_trunc_hour order by date_trunc_hour desc limit 3;~sessions exceeding the maximum limit of 1000 for past 3 hours.
6~hourly_query_count_for_past_3_hours~WITH ranked_queries AS ( SELECT n.subcluster_name, DATE_TRUNC('hour', qp.query_start::timestamp) AS date_trunc_hour, qp.user_name, COUNT(1) AS cnt, AVG(qp.query_duration_us) AS avg_query_duration_us, MIN(qp.query_duration_us) AS min_query_duration_us, MAX(qp.query_duration_us) AS max_query_duration_us, AVG(qp.processed_row_count) AS avg_processed_row_count, ROW_NUMBER() OVER ( PARTITION BY DATE_TRUNC('hour', qp.query_start::timestamp) ORDER BY COUNT(1) DESC ) AS rank_in_hour FROM netstats.query_profiles AS qp JOIN nodes AS n ON n.node_name = qp.node_name WHERE 1=1 {query_start>=from_date_time} {query_start<to_date_time} and n.subcluster_name = '<subcluster_name>' and qp.query_start >= DATE_TRUNC('hour', NOW()) - INTERVAL '3 hours' GROUP BY n.subcluster_name, date_trunc_hour, qp.user_name ) SELECT subcluster_name, date_trunc_hour, user_name, cnt, avg_query_duration_us, min_query_duration_us, max_query_duration_us, avg_processed_row_count FROM ranked_queries WHERE rank_in_hour <= 5 ORDER BY date_trunc_hour DESC, cnt DESC;~hourly query count of top 5 users for past 3 hours
7~memory_errors~select n.subcluster_name, em.event_timestamp, em.user_name, em.message from error_messages as em JOIN nodes AS n ON n.node_name = em.node_name where 1=1 and em.event_timestamp >= (TIMESTAMP {'from_date_time'} {to_date_time} {'issue_time'} - INTERVAL '3 hour') and n.subcluster_name = '<subcluster_name>' and em.event_timestamp <= {'from_date_time'} {'to_date_time'} {'issue_time'} and em.message ilike '%memory%' ORDER BY event_timestamp limit 5;~resource rejections due to memory related errors
8~all_errors~select n.subcluster_name, em.event_timestamp, em.user_name, em.message from error_messages as em JOIN nodes AS n ON n.node_name = em.node_name where 1=1 and em.event_timestamp >= (TIMESTAMP {'from_date_time'} {to_date_time} {'issue_time'} - INTERVAL '3 hour') and em.event_timestamp <= {'from_date_time'} {'to_date_time'} {'issue_time'} and n.subcluster_name = '<subcluster_name>' ORDER BY event_timestamp limit 5;~resource rejections due to all errors
9~delete_vectors_count~select created_time, schema_name, projection_name, sum(total_row_cnt) row_count, sum(deleted_row_cnt) deleted_rows, sum(delete_vector_cnt) dv_count, n.subcluster_name from netstats.storage_containers as sc JOIN nodes AS n ON n.node_name = sc.node_name where 1=1 {projection_name ILIKE 'table_name'} and created_time=(select max(created_time) from netstats.storage_containers) group by 1,2,3,7 order by 6 desc limit 20;~top 20 projections by delete vector count per subcluster
10~deleted_row_count~select created_time, schema_name, projection_name, sum(total_row_cnt) row_count, sum(deleted_row_cnt) deleted_rows, sum(delete_vector_cnt) dv_count, n.subcluster_name from netstats.storage_containers as sc JOIN nodes AS n ON n.node_name = sc.node_name where 1=1 {projection_name ILIKE 'table_name'} and created_time=(select max(created_time) from netstats.storage_containers) group by 1,2,3,7 order by 5 desc limit 20;~top 20 projections by deleted row count per subcluster
11~resource_pool_status~select node_name,memory_size_kb,general_memory_borrowed_kb,max_memory_size_kb from resource_pool_status where 1=1 {pool_name='pool_name'};~shows resource pool status for given resource pool